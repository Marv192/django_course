     1. Установка Django и создание проекта

1.2 Установка Джанго и создание проекта

python 3 -m venv {venv_name}                создание вирт окружения
source venv_name/bin/activate               активация вирт окружения
pip install django=={version}               Установка Джанго (в виртуальное окружение)
django-admin                                список команд
django-admin startproject {project_name}    создать проект (обычно домен сайта)
python3 manage.py runserver {port=8000}     запуск сайта локально
========================================================================================

1.3 Модель MTV. Добавление приложения

Models Templates Views берется шаблон и заполняется данными после маршрутизации по URL

python3 manage.py startapp {app_name}       создать приложение
в settings.py сайта нужно добавить приложение в INSTALLED_APPS
========================================================================================

1.4 Маршрутизация и функции представления

В {project_name}>.urls.py надо добавить пути и импортировать функции представлений из {app_name}}.views.py
========================================================================================

1.6 Динамические URL. Пользовательские конвертеры

В urls, path можно прописать тип переменной в скобках <> Типы переменных:
str (excluding path separator '/'),
int (0 and positive ints),
slug (str, int, '-', '_'),
uuid (str_lowercase, int, '-'),
path (non-empty string, including path separator '/')

можно использовать свои конвертеры вместо рег выражений, для этого нужно зарегистрировать его в urls.py,
напр. register_converter(converters.FourDigitYearConverter, "year4") (year4 - converter name)
========================================================================================

1.7 GET и POST-запросы. Обработчики исключений запросов

в запросах передается словарь "ключ-значение" после "?" через "&"
напр url/something/?{key_name}={value}&{key_name}={value}
получить словарь можно через функции GET POST (request.GET, request.POST)

ALLOWED_HOSTS — это настройка в settings.py (список строк), где указываются хосты (доменные имена или IP),
с которых Django разрешает принимать HTTP-запросы в режиме DEBUG = False.
Где и когда настраивать:
- В development (DEBUG = True) можно оставить пустой список, но лучше явно указать локальные хосты:
  ['localhost', '127.0.0.1']
- В production обязательно перечислить реальные домены вашего приложения.

Обработка ошибки 404:
в urls.py проекта добавляем handler404 = page_not_found и добавляем функцию page_not_found(request, exception)
в views, где возвращаем HttpResponseNotFound
Если в других представлениях поднять ошибку Http404(), тогда автоматически перенаправит на представление 404
========================================================================================

 1.8 Перенаправления (redirect). Функция reverse

301 - страница перемещена на другой постоянный URL-адрес (нужно указать redirect('url', permanent=True))
302 - страница перемещена временно на другой URL-адрес (по умолчанию)
Объявляется как return redirect("Куда", *args, permanent=...)
Куда: url, view func, view name(предпочтительно)
Можно использовать классы  HttpResponseRedirect для редиректа с кодом 302
                           HttpResponsePermanentRedirect для редиректа с кодом 301
Разницы, что использовать, функцию редирект или классы, нет
========================================================================================

     2. Шаблоны

 2.1 Введение в шаблоны (Django Template Language, DTL)

Импортировать функцию render_to_string, чтобы использовать шаблоны html страниц.
Джанго ищет шаблоны в папках templates (чтобы не находил шаблоны из других папок templates, которые находятся
выше по дереву, в папке создается подкатегория с названием приложения (в данном случае women) чтобы префикс
пути отличался и в функции представления пишется путь с префиксом('women/index.html'))

Реализация в функции представления:
def index(request):
    t = render_to_string('women/index.html')
    return HttpResponse(t)
========================================================================================

 2.2 Передача данных (переменных) в шаблоны

Переменные в html шаблонах пишутся в двойных фигурных скобках {{ variable }}
В функции представления она объявляется в словаре dict = {"var_name": value, ...} и передается 3м параметром
return render(request, 'women/index.html', context={dict})
В словарь можно передать переменные любых типов (float, bool, set, dict, class, etc...), они будут
отображены на сайте в строковом представлении
Чтобы обратиться к атрибуту словаря или класса в html шаблоне, нужно писать атрибут после "."
(dict.{key}, class.{attr_name})
Для обращения по индексу в списке, так же через "." (list.0)
========================================================================================

 2.3 Стандартные шаблонные фильтры

Чтобы применить фильтр в html шаблоне, в переменной после названия нужно поставить "|", после нее имя фильтра,
двоеточие и параметры фильтра, если есть. Параметры пишутся строкой (в кавычках)
Напр {{ variable|<filter_name>:"<filter_params>" }}
Документация по фильтрам: https://django.fun/docs/django/4.2/ref/templates/builtins/#built-in-filter-reference
Фильтры можно импортировать из django.template.defaultfilters и использовать как функции
========================================================================================

 2.4 Теги шаблонов. Теги if и for

syntax: {% TagName [params] %}
действие
{% endTagName%}

Напр
<ul>
{% for athlete in athlete_list %}
    <li>{{ athlete.name }}</li>
{% endfor %}
</ul>
========================================================================================

 2.5 Шаблонный тег url

{% url "urlName" v1 v2 or (arg1=v1 arg2=v2) %}
Пример <p><a href="{% url 'post' p.id %}">Читать пост</a></p>
========================================================================================

 2.6 Наследование шаблонов. Тег include

Создаем директорию templates в папке проекта, добавляем эту папку в settings.py > templates > dirs
Создаем шаблоны в этой папке (base.html)
В html файлах отдельных страниц нужно прописать

{% extends 'ИмяШаблона.html' only(optional) %}
{% block content %}
<h1>{{ title }}</h1>
{% endblock %}

В block помещается весь контент отдельных страниц. Extends выбирает шаблон в который будет вставлен контент

Для дублирования кода используется {% include 'women/includes/nav.html' %}
Файл nav html наследует все переменные, если не используется флaг only
Так же можно передать только определенные переменные используя only with var_name='value'
========================================================================================

 2.7 Подключение статических файлов

В режиме отладки (DEBUG=True в settings.py) Джанго ищет статические файлы только внутри приложений в папке
static, приложение должно быть зарегистрировано в installed apps в settings.py
В режиме эксплуатации (DEBUG=False) ищет файлы только в папке static всего проекта (sitewomen/static).

Чтобы собрать файлы из приложений в общую папку используется команда python3 manage.py collectstatic
Собирает из стандартных и указанных нестандартных путей.

Подключение статических фалов
STATIC_URL - префикс URL-адреса для статических файлов
STATIC_ROOT - путь к общей статической папке. Для сбора всей статики в единый каталог.
STATICFILES_DIRS - список дополнительных путей к стат файлам, используемых дял сбора и для режима отладки

Чтобы статические файлы (напр, css) работали в html шаблоне, надо прописать {% load static %}, в head
прописать <link type="text/css" href="{% static 'APP_NAME/css/styles.css' %}" rel="stylesheet" />

Чтобы статика работала в режиме DEBUG=False, можно запустить сервер командой
python3 manage.py runserver --insecure
========================================================================================

 2.8 Пользовательские теги шаблонов

simple tags - простые теги
inclusion tags - включающие теги (может возвращать фрагмент html страницы)

Все теги должны располагаться в папке templatetags, внутри приложения, в ней должен быть __init__.py, чтобы
эта директория была питон пакетом.

Для регистрации тега, нужно  создать экземпляр класса Library, через который происходит регистрация
собственных шаблонных тегов:
register = template.Library()

и воспользоваться им как декоратором перед функцией
@register.simple_tag()
def get_categories():
    return views.cats_db

Чтобы можно было использовать теги, нужно загрузить файл с тегами в html шаблоне({% load women_tags %})
Результат работы тега можно положить в переменную(ссылку) используя as ({% get_categories as categories %})
После этого можно использовать эту ссылку ({% for cat in categories %})
========================================================================================

  3. Введение в ORM и модели

 3.1 Что такое БД, SQL и ORM
Django поддерживает PostgreSQL, MariaDB, MySQL, Oracle, SQLite(по умолчанию) (Все реляционные БД)
Через ORM(Object-Relational Mapping) можно писать код, который будет работать с разными БД,
не надо писать SQL запросы.

Чтобы подключить другую БД, надо в settings.py изменить запись DATABASES.
Класс - это таблица БД, записи в таблице - это объекты класса.

Прописывать все модели надо в models.py.
Создаваемый класс должен наследоваться от models.Model (class Women(models.Model)), прописываем все поля
таблицы, id прописывать не надо, создается автоматически. Пример:
  title = models.CharField(max_length=255) - макс 255 символов
  content = models.TextField(blank=True) = текст, не обязательно для заполнения, False - не может быть пустым
  time_create = models.DateTimeField(auto_now_add=True) - обновляется только при создании записи
  time_update = models.DateTimeField(auto_now=True) - обновляется при каждом изменении
  is_published = models.BooleanField(default=True) - по ум. True

Больше о полях модели: https://django.fun/docs/django/5.0/ref/models/fields/
========================================================================================

 3.2 Создание и запуск файлов миграций

Чтобы создать таблицу в БД, нужно сделать файл миграции и выполнить его.
Файлы миграции появляются в пипке migrations приложения.

python3 manage.py makemigrations - создать файл миграции (в консоли)
python3 manage.py sqlmigrate {appname} {migration_file_number} (women 0001) - посмотреть SQL запросы
python3 manage.py migrate - выполнить миграцию
========================================================================================

 3.3 Понятие CRUD. Добавление записей в таблицу БД

CRUD (Create Read Update Delete)
Класс - это структура таблицы.
Экземпляр - это запись с данными в этой таблице (строка).
python3 manage.py shell - открыть оболочку Джанго
from women.models import Women - импортируем класс, чтобы можно было с ним работать
Women(title='Анджелина Джоли', content='Биография Анджелины Джоли') - создать новый объект, данные не добавлены
w1 = _ ('_' ссылается на последнюю операцию)
w1.save() - сделать запись в БД
мы можем обращаться к объекту через (w1.id, w1.title, ...)

from django.db import connection - чтобы можно было посмотреть sql запросы
connection.queries - посмотреть список запросов (queries[-1] - последний запрос)

Можно сначала создать объект(w3 = Women()), а потом добавлять данные
w3.title = 'Джулия Робертс'
w3.content = 'биография Джулии Робертс'
w3.save() - записать в БД

pip install ipython - для улучшенной оболочки в Джанго(python3 manage.py shell)
pip install django-extensions - для упрощения с ORM командами в консоли
добавить 'django_extensions' в settings.py > INSTALLED_APPS

python3 manage.py shell_plus --print-sql - сразу показывает выполняемы SQL запросы
========================================================================================

 3.4 Методы выбора записей из таблиц

Women.objects.create - Создать объект и добавить запись в таблицу
Women.objects.all - получить записи таблицы, получим
<QuerySet [<Women: Women object (1)>, <Women: Women object (2)>,... >.
Чтобы получить читаемые данные, в models.py нужно создать функцию
def __str__(self):
    return self.title

w = Women.objects.all()[0] - получить 1ю запись
w = Women.objects.all()[:3] - получить 3 записи (sql запрос не выполнялся)
при вызове w, sql запрос выполнится.

Чтобы не читать всю таблицу, вместо метода all, нужно использовать метод filter
(Women.objects.filter(title='Энн Хэтэуей'))
Ищется строка целиком. Если написать "Энн", не найдет никаких записей.

Условия для метода filter:
Пример: Women.objects.filter(pk__gt=2) (pk - primary key, обычно id)
<attr_name>__gte=num - >=
<attr_name>__gt=num - >
<attr_name>__lte=num - <=
<attr_name>__lt=num - <
__contains - содержит(напр для поиска вхождения в строке)
__icontains - поиск по вхождению независимо от регистра(не работает в SQLite)
__in - поиск по вхождению в список(pk__in=[2, 5, 11, 12])
Для применения нескольких условий в filter, перечисляем их через ",".

Метод exclude (противоположность filter) - исключит все записи найденные по указанному условию
Women.objects.exclude(pk=2) - выдаст все записи кроме первичного ключа = 2.

filter и exclude всегда возвращают список, даже если находится одна запись.
Для получения одной записи, нужно использовать метод get, если не будет найдено ни одной записи по условию,
метод вернет ошибку, так же будет ошибка если найдется несколько записей.
========================================================================================

 3.5 Сортировка, изменение и удаление записей

Для сортировки используется метод order_by.
Women.objects.all().order_by("title") = Women.objects.order_by("title") (без all())
Можно использовать после метода filter(), напр. Women.objects.filter(pk__gte=4).order_by("title")
Для сортировки по убыванию, нужно перед атрибутом поставить "-" (order_by("-title"))

Сортировку можно прописать во вложенном классе Meta
Class women:
    class Meta:
        ordering = ['-time_create', 'title', ...]
По умолчанию запросы будут сортировать выборку в прописанном порядке
В классе Meta можно так же делать индексирование
    class Meta:
        indexes = [
            models.Index(fields=['-time_create'])
        ]

 Изменение данных:
Получаем запись wu = Women.objects.get(pk=2)
wu.title = 'New Title'
wu.content = 'New Content'
wu.save() чтобы записать изменения в БД

Для изменения всех объектов: Women.objects.update(is_published=0)
Для изменения выборочных записей нельзя применять метод all(), т.к. update не применяется к срезам, нужно
использовать filter(). Пример: Women.objects.filter(pk__lte=4).update(is_published=1)
get().update() выдаст ошибку, потому что update работает только со списком (QuerySet)

 Удаление записей
wd = Women.objects.filter(pk__gte=5)    делаем выборку для удаления
wd.delete()     удаляем
Women.objects.filter(pk__gte=5).delete()    можно объединить
========================================================================================

 3.6 Слаги (slug) в URL-адресах. Метод get_absolute_url()
Слаг - уникальный фрагмент url адреса
В views.py чтобы получить запись из БД, используется функция get_object_or_404(table_name, filter)
Пример get_object_or_404(Women, pk=4)

т.к. pl уникален, то и слаг получится уникальным.
for w in Women.objects.all():
   ...:     w.slug = 'slug-'+str(w.pk)
   ...:     w.save()

Для отображения адреса со слагом, в urls.py меняем путь представления на 'post/<slug:post_slug>/'

Добавляем в класс Women функцию
    def get_absolute_url(self):
        return reverse('post', kwargs={'post_slug': self.slug })
Т.к. self это объект, он может выдать слаг через self.slug, функцию reverse возвращает полный url адрес
В шаблоне index.html нужно поменять формирование ссылки на <a href="{{ p.get_absolute_url }}">